import csv
import xml.etree.ElementTree as ET
from dateutil import parser as date_parser
from datetime import datetime
import iso8601
import os
import xml.dom.minidom as minidom

# --- Paths ---
BASE_DIR = os.path.dirname(os.path.abspath(__file__))
CSV_FILE = os.path.join(BASE_DIR, "..", "tal_episodes.csv")
XML_FILE = os.path.join(BASE_DIR, "..", "feed.xml")

# --- Date parsing helpers ---
def parse_date(date_str):
    if not date_str:
        return None
    try:
        return iso8601.parse_date(date_str)
    except Exception:
        try:
            return date_parser.parse(date_str)
        except Exception:
            return None

def sort_key(row):
    date_str = row['pubDate'].strip() or row['releaseDate'].strip()
    dt = parse_date(date_str)
    return dt or datetime.min

# --- Main ---
def main():
    # Read CSV
    with open(CSV_FILE, newline="", encoding="utf-8") as f:
        reader = list(csv.DictReader(f))
    
    # Sort descending by date
    rows = sorted(reader, key=sort_key, reverse=True)

    # Build RSS
    rss = ET.Element('rss', version="2.0", attrib={"xmlns:itunes": "http://www.itunes.com/dtds/podcast-1.0.dtd"})
    channel = ET.SubElement(rss, 'channel')

    ET.SubElement(channel, 'title').text = "This American Archive"
    ET.SubElement(channel, 'link').text = "https://www.thisamericanlife.org"
    ET.SubElement(channel, 'description').text = "Autogenerated feed of the This American Life archive with explicit and clean episodes."
    ET.SubElement(channel, 'language').text = "en"
    ET.SubElement(channel, 'copyright').text = "Copyright Â© Ira Glass / This American Life"
    ET.SubElement(channel, 'itunes:image', href="https://i.imgur.com/pTMCfn9.png")

    for row in rows:
        release_date_iso = row['releaseDate'].strip()
        release_date = release_date_iso.split("T")[0] if "T" in release_date_iso else release_date_iso

        pub_dt = parse_date(row['pubDate'].strip()) if row['pubDate'].strip() else None
        rel_dt = parse_date(row['releaseDate'].strip()) if row['releaseDate'].strip() else None
        title_base = row['title'].strip()
        title = title_base
        if pub_dt and rel_dt and (pub_dt.year != rel_dt.year or pub_dt.isocalendar()[1] != rel_dt.isocalendar()[1]):
            title += " - Repeat"

        # Normal and clean items
        for clean_suffix, enclosure_url in [(False, row['enclosure'].strip()), (True, row['clean'].strip())]:
            if clean_suffix and not enclosure_url:
                continue
            item_element = ET.SubElement(channel, 'item')
            ET.SubElement(item_element, 'title').text = title + (" (Clean)" if clean_suffix else "")
            ET.SubElement(item_element, 'link').text = row['link'].strip() + ("?clean" if clean_suffix else "")
            ET.SubElement(item_element, 'itunes:episode').text = row['episode'].strip()
            ET.SubElement(item_element, 'itunes:episodeType').text = "full"

            # Use CSV explicit field; force true if no clean URL
            explicit_flag = row['explicit'].strip().upper() == "TRUE" or (not clean_suffix and not row['clean'].strip())
            ET.SubElement(item_element, 'itunes:explicit').text = "true" if explicit_flag else "false"

            desc_dt = parse_date(row['releaseDate'].strip() or row['pubDate'].strip())
            desc_date_str = desc_dt.strftime("%Y-%m-%d") if desc_dt else ""
            desc_text = f"{row['description'].strip()}\n\nOriginally Aired: {desc_date_str}"
            ET.SubElement(item_element, 'description').text = desc_text

            
#            desc_dt = parse_date(row['pubDate'].strip() or row['releaseDate'].strip())
#            desc_date_str = desc_dt.strftime("%Y-%m-%d") if desc_dt else ""
#            desc_text = f"{row['description'].strip()}\n\nOriginally Aired: {desc_date_str}"
#            ET.SubElement(item_element, 'description').text = desc_text

            pub_date_val = row['pubDate'].strip() or row['releaseDate'].strip()
            ET.SubElement(item_element, 'pubDate').text = pub_date_val
            ET.SubElement(item_element, 'enclosure', url=enclosure_url, type="audio/mpeg")

    # Pretty-print XML
    xml_str = ET.tostring(rss, encoding="utf-8")
    pretty_xml = minidom.parseString(xml_str).toprettyxml(indent="  ")
    with open(XML_FILE, "w", encoding="utf-8") as f:
        f.write(pretty_xml)

if __name__ == "__main__":
    main()
